{"meta":{"title":"Zpreston","subtitle":null,"description":"Zpreston's Blog","author":"Zpreston","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-08-18T08:53:19.000Z","updated":"2017-08-18T08:53:19.936Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树中和为某一值的路径","slug":"二叉树中和为某一值的路径","date":"2017-08-21T09:28:06.000Z","updated":"2017-08-21T10:10:36.236Z","comments":true,"path":"2017/08/21/二叉树中和为某一值的路径/","link":"","permalink":"http://yoursite.com/2017/08/21/二叉树中和为某一值的路径/","excerpt":"","text":"问题描述输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 分析注意问题描述中的路径是从根节点到叶节点，搜索策略应该采用广度优先搜索，也就是先序遍历 需要两个存储变量，一个变量path存储当前搜索路径上的所有节点，一个变量result存储符合要求的所有路径每当搜索到一个节点，都将当前节点添加到path中当搜索到叶子节点时，判断当前路径上的节点值的和是否与目标值相等，相等则将当前路径添加到result中，之后在path中将当前叶子节点移除，回溯到上个节点继续判断由此可以看出path的操作数据的方式跟栈(Stack)很相似，可以将path定义成栈(Stack) 判断路径上的节点值的和是否与目标值相等时，可以有两种方法： target值初始为0，每当搜索到一个节点，把节点值累加到target上，搜索到叶子节点时判断target值与目标值是否一致 target值初始为目标值，每当搜索到一个节点，下次搜索时将target值减去当前节点值，搜索到叶子节点时判断target值与叶子节点值是否一致本次程序采用的时第2种方法 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//二叉树的数据结构public class TreeNode&#123; int val=0; TreeNode left=null; TreeNode right=null; public TreeNode(int val)&#123;this.val=val;&#125;&#125;public class Solution&#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(root==null) return result; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); pathList(root,target,result,path); return result; &#125; /* 参数：二叉树的根节点，目标值，当前符合的所有路径，当前的搜索路径 返回：无 */ public void pathList(TreeNode root,int target,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result,Stack&lt;Integer&gt; path)&#123; int num=root.val; //将当前搜索节点加入path中 path.push(num); //当搜索到叶子节点时 if(root.left==null &amp;&amp; root.right==null)&#123; //当前节点值与target值相等，说明path中的路径符合要求 if(num==target)&#123; ArrayList&lt;Integer&gt; tmp=new ArrayList&lt;Integer&gt;(); for(int i:path)&#123; tmp.add(i); &#125; //将当前搜索路径加入到result中 result.add(tmp); &#125; return; &#125; /* 注意每次递归向下搜索时应该将target值减去已搜索的节点值 每次回溯时应该移除该节点值 */ if(root.left!=null)&#123; pathList(root.left,target-num,result,path); path.pop(); &#125; if(root.right!=null)&#123; pathList(root.right,target-num,result,path); path.pop(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[]},{"title":"重建二叉树","slug":"重建二叉树","date":"2017-08-21T06:08:13.000Z","updated":"2017-08-21T07:16:11.951Z","comments":true,"path":"2017/08/21/重建二叉树/","link":"","permalink":"http://yoursite.com/2017/08/21/重建二叉树/","excerpt":"","text":"问题描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。分析假设输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6} 前序遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树 中序遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树 由前序和中序的遍历顺序我们可以得到以下信息： 1.前序序列的第一个节点总是该序列的根节点 2.在中序序列中，以1得到的根节点为界，左边的序列为根节点的左子树，右边的序列为右子树 3.通过2将前序和中序序列进行划分得到的左子树和右子树同样适用上述规则 显然，从信息3可以看出来这道题可以采用递归的方式解决 程序1234567891011121314151617181920212223242526272829303132//二叉树结构public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return myReConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); &#125;/*参数：前序序列，前序序列第一个元素和最后一个元素的索引，后序序列，后序序列第一个元素和最后一个元素的索引返回：重建二叉树的头结点*/ public TreeNode myReConstructBinaryTree(int pre[],int preHead,int preTail,int in[],int inHead,int inTail)&#123; //头索引大于尾索引，说明序列的左子树或者右子树为空，返回null if(preHead&gt;preTail || inHead&gt;inTail) return null; //前序序列的第一个节点是该序列的根节点 TreeNode root=new TreeNode(pre[preHead]); for(int i=inHead;i&lt;=inTail;i++)&#123; //在中序序列中找到该节点 if(pre[preHead]==in[i])&#123; //节点左边为左子树，右边为右子树，对他们分别进行重建二叉树的操作 root.left=myReConstructBinaryTree(pre,preHead+1,preHead+i-inHead,in,inHead,i-1); root.right=myReConstructBinaryTree(pre,preHead+i-inHead+1,preTail,in,i+1,inTail); &#125; &#125; //返回重建后的二叉树的根节点 return root; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-18T07:35:09.375Z","updated":"2017-08-21T01:01:01.837Z","comments":true,"path":"2017/08/18/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}