{"meta":{"title":"Zpreston","subtitle":null,"description":"Zpreston's Blog","author":"Zpreston","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-08-18T08:53:19.000Z","updated":"2017-08-18T08:53:19.936Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"SSM框架整合Redis","slug":"SSM框架整合Redis","date":"2017-09-05T08:11:37.000Z","updated":"2017-09-05T09:34:18.529Z","comments":true,"path":"2017/09/05/SSM框架整合Redis/","link":"","permalink":"http://yoursite.com/2017/09/05/SSM框架整合Redis/","excerpt":"","text":"上一篇博文SSM框架搭建及简单应用中已经介绍了SSM框架的搭建流程，这次将在前面搭建的SSM框架基础上整合Redis。Redis是一种key-value数据库，不同于传统的关系型数据库，Redis是一种非关系型数据库（NoSQL），其数据类型包括字符串、列表、哈希、集合和有序集合。由于Redis在内存操作数据，存取方便快捷，但易受内存容量的限制，所以一般不将Redis用作主数据库，而是用来存取一些数据量小且对实时性要求较高的数据，比如缓存场景。在介绍完整合Redis的流程后，我会写一个通过Redis实现缓存的例子。 SSM整合Redis 在pom.xml中添加依赖包 12345678910111213&lt;!-- spring-redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redis客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; 在resource包下新建redis.properties文件 1234567redis.host = localhostredis.port = 6379redis.pass =redis.maxIdle = 200redis.maxActive = 1024redis.maxWait = 10000redis.testOnBorrow = true 在spring文件夹下新建spring-redis.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 读取redis配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:redis.properties\" /&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\" /&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\" &gt; &lt;property name=\"hostName\" value=\"$&#123;redis.host&#125;\"/&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;redis.pass&#125;\"/&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\"/&gt; &lt;/bean&gt; &lt;!-- 连接池工厂配置 --&gt; &lt;bean id=\"redisTemplate\" class=\" org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;!-- 需配置Serializer，Java对象经序列化后才能在Redis数据库中存取 --&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /&gt; &lt;/property&gt; &lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" /&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 至此，SSM框架中Redis的整合已经完成，下面实现一个页面缓存的例子来验证。 利用Redis实现页面缓存 编写序列化工具类SerializeUtil类对象需要经过序列化或者反序列化才能在Redis数据库中存取，SerializeUtil负责对类对象进行序列化和反序列操作 123456789101112131415161718192021222324252627282930313233public class SerializeUtil &#123; public static byte[] serialize(Object object)&#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try&#123; baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); byte[] bytes = baos.toByteArray(); return bytes; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public static Object unserialize(byte[] bytes)&#123; if(null == bytes)&#123; return null; &#125; ByteArrayInputStream bais = null; try&#123; bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 编写Redis数据库工具类JedisUtilJedisUtil工具负责连接Redis数据库 1234567891011121314151617181920212223242526272829303132333435363738public class JedisUtil &#123; private static String ADDR = \"localhost\"; private static int PORT = 6379; private static int MAX_ACTIVE = 1024; private static int MAX_IDLE = 200; private static int MAX_WAIT = 10000; private static int TIMEOUT = 10000; private static boolean TEST_ON_BORROW = true; private static JedisPool jedisPool = null; static&#123; try&#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(MAX_IDLE); config.setMaxWaitMillis(MAX_WAIT); config.setTestOnBorrow(TEST_ON_BORROW); jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public synchronized static Jedis getJedis()&#123; try&#123; if(jedisPool != null)&#123; Jedis jedis = jedisPool.getResource(); return jedis; &#125;else&#123; return null; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); return null; &#125; &#125;&#125; 编写缓存类RedisCache实现页面缓存需要实现Java中的Cache接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class RedisCache implements Cache &#123; private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private String id; public RedisCache(final String id)&#123; if(null == id)&#123; throw new IllegalArgumentException(\"Cache instances require an ID\"); &#125; this.id = id; &#125; @Override public String getId()&#123; return this.id; &#125; @Override public void putObject(Object key, Object value) &#123; JedisUtil.getJedis().set(SerializeUtil.serialize(key.toString()), SerializeUtil.serialize(value)); &#125; @Override public Object getObject(Object key) &#123; Object value = SerializeUtil.unserialize(JedisUtil.getJedis() .get(SerializeUtil.serialize(key.toString()))); return value; &#125; @Override public Object removeObject(Object key) &#123; return JedisUtil.getJedis().expire(SerializeUtil.serialize(key.toString()), 0); &#125; @Override public void clear() &#123; JedisUtil.getJedis().flushDB(); &#125; @Override public int getSize() &#123; return Integer.valueOf(JedisUtil.getJedis().dbSize().toString()); &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125;&#125; 在domain包下新建Person类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*** * create table `redis_person`( * `id` int not null comment '用户id', * `name` varchar(20) not null comment '用户姓名', * `pwd` varchar(20) not null comment '密码', * primary key(`id`) * )engine=InnoDB auto_increment=1000 default charset=utf8 comment='redis用户表'; * insert into `redis_person` values * (1,'张三','123456'), * (2,'李四','123456'), * (3,'王五','123456'); */public class Person implements Serializable &#123; private static final long serialVersionUID = -1695973853274402680L; private int id; private String name; private String pwd; public Person()&#123;&#125; public Person(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 在dao包下新建PersonDao接口 12345public interface PersonDao &#123; Person getPersonById(int id);&#125; 在service包下新建PersonService接口 12345public interface PersonService &#123; Person getPersonById(int id);&#125; 在serviceImpl包下新建PersonServiceImpl类 1234567891011121314151617@Service(\"personService\")public class PersonServiceImpl implements PersonService&#123; @Autowired private PersonDao personDao; @Override public Person getPersonById(int id) &#123; Person person = null; try&#123; person = personDao.getPersonById(id); &#125;catch(DataAccessException e)&#123; System.out.println(e.getLocalizedMessage()); &#125; return person; &#125;&#125; 在mapper包下新建PersonDao.xmlPersonDao文件负责把PersonDao和缓存类RedisCache进行映射，当页面需要数据时首先先从缓存中查找，若查找不到数据则会连接主数据库进行查找，并将这些数据存入Redis数据库作为缓存数据 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.zpreston.dao.PersonDao\"&gt; &lt;cache type=\"com.zpreston.redis.RedisCache\"/&gt; &lt;select id=\"getPersonById\" parameterType=\"int\" resultType=\"Person\" useCache=\"true\"&gt; SELECT * FROM `redis_person` WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在controller包下新建PersonController类 1234567891011121314151617@Controllerpublic class PersonController &#123; @Autowired private PersonService personService; @RequestMapping(value=\"/toQueryPerson\") public String toQueryPerson(Model model)&#123; Person person = personService.getPersonById(1); String personJson = new Gson().toJson(person); Logger logger = LoggerFactory.getLogger(PersonController.class); logger.info(personJson); model.addAttribute(\"person\",personJson); return \"showUser\"; &#125;&#125; 例子中用到的视图都是上一篇博文SSM框架搭建及简单应用的例子，只在showUser.jsp中进行了少量的改动 12345678910&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ page isELIgnored=\"false\" pageEncoding=\"utf-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;person = $&#123;person&#125;&lt;/body&gt;&lt;/html&gt; 验证 在浏览器中输入http://localhost:8080/toQueryPerson结果如下图。同时控制台中的信息显示，这些数据是通过查询数据库得到的 再次在浏览器中输入http://localhost:8080/toQueryPerson结果如下图。同时控制台中的信息没有查询数据库的相关信息，说明数据是从缓存中读取","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}],"keywords":[]},{"title":"SSM框架搭建及简单应用","slug":"SSM框架搭建及简单应用","date":"2017-09-01T08:37:47.000Z","updated":"2017-09-01T10:30:49.738Z","comments":true,"path":"2017/09/01/SSM框架搭建及简单应用/","link":"","permalink":"http://yoursite.com/2017/09/01/SSM框架搭建及简单应用/","excerpt":"","text":"开发环境 IntelliJ IDEA Maven Tomcat MySQL SSM框架搭建用IntelliJ创建Maven项目，不知道的童鞋自行搜索，这里不再占据篇幅赘述。目录结构可以参考 配置pom.xml文件，pom配置文件是Maven项目的核心，他可以很方便地管理项目的依赖包，无需手动导入，具体的配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zpreston&lt;/groupId&gt; &lt;artifactId&gt;MyFirstSSM&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;MyFirstSSM Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;org.apache.logging.log4j.version&gt;2.6.2&lt;/org.apache.logging.log4j.version&gt; &lt;mysql.version&gt;5.1.37&lt;/mysql.version&gt; &lt;com.alibaba.druid.version&gt;1.0.25&lt;/com.alibaba.druid.version&gt; &lt;com.mybatis.mybatis.version&gt;3.4.1&lt;/com.mybatis.mybatis.version&gt; &lt;com.mybatis.mybatis_spring.version&gt;1.3.0&lt;/com.mybatis.mybatis_spring.version&gt; &lt;com.google.gson.version&gt;2.7&lt;/com.google.gson.version&gt; &lt;javax.servlet.version&gt;3.1.0&lt;/javax.servlet.version&gt; &lt;org.springframework.version&gt;4.3.2.RELEASE&lt;/org.springframework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 1.日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- druid是阿里巴巴开源出来的数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;com.alibaba.druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;com.mybatis.mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;com.mybatis.mybatis_spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.Servlet web --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet版本设置--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 4.Spring --&gt; &lt;!-- 1)Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)Spring DAO层 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)Spring test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;com.google.gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;MyFirstSSM&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 配置web.xml文件，web.xml文件包含了web项目的全局配置，可以指定前端控制器DispatcherServlet的拦截规则和SSM框架配置文件的加载路径，具体配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\" metadata-complete=\"true\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;display-name&gt;MySSM&lt;/display-name&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--druid ==&gt; WEB方式监控配置--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;druidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;/public/*,*.js,*.css,/druid*,*.jsp,*.swf&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalSessionName&lt;/param-name&gt; &lt;param-value&gt;sessionInfo&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;profileEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;druidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt; 配置jdbc.properties文件，jdbc.properties文件是对数据库相关参数的配置123jdbc.driver = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/testjdbc.username = root 我的test数据库中，root用户无需密码，故此处没有声明jdbc.password参数，有密码的自行加上 配置mybatis.config文件，mybatis.config是mybatis的全局配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 配置SSM框架最主要的三个配置文件 spring-dao.xml，spring-service.xml，spring-web.xmlspring-dao.xml主要用于整合mybatis，将dao层与mapper层下的文件映射起来，简化开发人员对数据库中数据的操作dao文件是接口文件，dao文件中的每个接口方法对应mapper文件的一个数据库操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;!-- 使用数据库配置文件解耦 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"1\" /&gt; &lt;property name=\"minIdle\" value=\"1\" /&gt; &lt;property name=\"maxActive\" value=\"10\" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"10000\" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\" /&gt; &lt;property name=\"testWhileIdle\" value=\"true\" /&gt; &lt;!-- 这里建议配置为TRUE，防止取到的连接不可用 --&gt; &lt;property name=\"testOnBorrow\" value=\"true\" /&gt; &lt;property name=\"testOnReturn\" value=\"false\" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\" /&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\" /&gt; &lt;!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --&gt; &lt;property name=\"defaultAutoCommit\" value=\"true\" /&gt; &lt;!-- 验证连接有效与否的SQL，不同的数据配置不同 --&gt; &lt;property name=\"validationQuery\" value=\"select 1 \" /&gt; &lt;property name=\"filters\" value=\"stat\" /&gt; &lt;property name=\"proxyFilters\"&gt; &lt;list&gt; &lt;ref bean=\"logFilter\" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.zpreston.domain\"/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.zpreston.dao\"/&gt; &lt;/bean&gt; &lt;!-- 上面的druid的配置 --&gt; &lt;bean id=\"logFilter\" class=\"com.alibaba.druid.filter.logging.Slf4jLogFilter\"&gt; &lt;property name=\"statementExecutableSqlLogEnable\" value=\"false\" /&gt; &lt;/bean&gt;&lt;/beans&gt; spring-service.xml主要用于整合Spring，自动扫描被@Service注释的类，并自动创建实例分配给被@Autowired或者@Resource注释的对象12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=\"com.zpreston.service.serviceImpl\" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt;&lt;/beans&gt; spring-web.xml主要用于整合SpringMVC，可以设置viewResolver，自动在返回字符串上加上设置的前缀和后缀，同时会自动扫描@Controller注释的类，这些类会根据设置的mapping拦截匹配的请求1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean配置 --&gt; &lt;context:component-scan base-package=\"com.zpreston.controller\"&gt; &lt;!-- 制定扫包规则 ,只扫描使用@Controller注解的JAVA类 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 以上就是SSM框架的搭建过程，接下来我会以一个例子来验证框架是否搭建成功 验证 在domain包（也称model）下新建User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*** 创建数据库用户表： CREATE TABLE `ssm_user` ( `login_id` int NOT NULL COMMENT '登陆ID', `pwd` varchar(20) NOT NULL COMMENT '用户密码', `name` varchar(100) NOT NULL COMMENT '用户姓名', PRIMARY KEY (`login_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT='SSM用户表'; 插入默认数据： INSERT INTO `user` (`login_id`,`pwd`,`name`) VALUES (1,'123456','张三'), (2,'123456','李四'), (3,'123456','王五'), (4,'123456','赵六'); */public class User implements Serializable &#123; private int login_id; private String pwd; private String name; public int getLogin_id() &#123; return login_id; &#125; public void setLogin_id(int login_id) &#123; this.login_id = login_id; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"login_id=\" + login_id + \", pwd='\" + pwd + '\\'' + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 在dao包下新建UserDao接口 123public interface UserDao &#123; User findUserByLoginId(int login_id);&#125; 在mapper文件下新建UserDao.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace指定映射的是dao包下的哪个接口类，id对应接口类的接口方法 --&gt;&lt;mapper namespace=\"com.zpreston.dao.UserDao\"&gt; &lt;select id=\"findUserByLoginId\" parameterType=\"int\" resultType=\"User\"&gt; SELECT * FROM `ssm_user` WHERE login_id = #&#123;login_id&#125; &lt;/select&gt;&lt;/mapper&gt; 在service包下新建UserDaoService接口 123public interface UserDaoService &#123; User findUserByLoginId(int login_id);&#125; 在serviceImpl包下新建UserServiceImpl类 1234567891011@Service(\"userService\")public class UserServiceImpl implements UserDaoService &#123; @Autowired private UserDao userDao; @Override public User findUserByLoginId(int login_id) &#123; return userDao.findUserByLoginId(login_id); &#125;&#125; 在controller包下新建UserController类 12345678910111213141516171819202122@Controllerpublic class UserController &#123; @Autowired private UserServiceImpl userService; @RequestMapping(\"/index\") public String forIndex()&#123; return \"index\"; &#125; @RequestMapping(\"/findUser\") public String findUser(Model model)&#123; User user = userService.findUserByLoginId(1); String userJson = new Gson().toJson(user); Logger logger = LoggerFactory.getLogger(UserController.class); logger.info(userJson); model.addAttribute(\"user\", userJson); return \"showUser\"; &#125;&#125; 视图中用到的两个jsp文件分别为index.jsp何showUser.jspindex.jsp 12345678910&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;form action=\"findUser\" method=\"get\"&gt; &lt;input type=\"submit\" value=\"submit\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; showUser.jsp12345678910&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ page isELIgnored=\"false\" pageEncoding=\"utf-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;user = $&#123;user&#125;&lt;/body&gt;&lt;/html&gt; 结果配置Tomcat启动后，浏览器输入http://localhost:8080/index点击submit，转发到http://localhost:8080/showUser","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}],"keywords":[]},{"title":"初探SpringMVC-第一个SpringMVC应用","slug":"初探SpringMVC-第一个SpringMVC应用","date":"2017-08-25T10:09:31.000Z","updated":"2017-08-25T10:09:31.163Z","comments":true,"path":"2017/08/25/初探SpringMVC-第一个SpringMVC应用/","link":"","permalink":"http://yoursite.com/2017/08/25/初探SpringMVC-第一个SpringMVC应用/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"二叉树中和为某一值的路径","slug":"二叉树中和为某一值的路径","date":"2017-08-21T09:28:06.000Z","updated":"2017-08-21T10:10:36.236Z","comments":true,"path":"2017/08/21/二叉树中和为某一值的路径/","link":"","permalink":"http://yoursite.com/2017/08/21/二叉树中和为某一值的路径/","excerpt":"","text":"问题描述输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 分析注意问题描述中的路径是从根节点到叶节点，搜索策略应该采用广度优先搜索，也就是先序遍历 需要两个存储变量，一个变量path存储当前搜索路径上的所有节点，一个变量result存储符合要求的所有路径每当搜索到一个节点，都将当前节点添加到path中当搜索到叶子节点时，判断当前路径上的节点值的和是否与目标值相等，相等则将当前路径添加到result中，之后在path中将当前叶子节点移除，回溯到上个节点继续判断由此可以看出path的操作数据的方式跟栈(Stack)很相似，可以将path定义成栈(Stack) 判断路径上的节点值的和是否与目标值相等时，可以有两种方法： target值初始为0，每当搜索到一个节点，把节点值累加到target上，搜索到叶子节点时判断target值与目标值是否一致 target值初始为目标值，每当搜索到一个节点，下次搜索时将target值减去当前节点值，搜索到叶子节点时判断target值与叶子节点值是否一致本次程序采用的时第2种方法 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//二叉树的数据结构public class TreeNode&#123; int val=0; TreeNode left=null; TreeNode right=null; public TreeNode(int val)&#123;this.val=val;&#125;&#125;public class Solution&#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(root==null) return result; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); pathList(root,target,result,path); return result; &#125; /* 参数：二叉树的根节点，目标值，当前符合的所有路径，当前的搜索路径 返回：无 */ public void pathList(TreeNode root,int target,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result,Stack&lt;Integer&gt; path)&#123; int num=root.val; //将当前搜索节点加入path中 path.push(num); //当搜索到叶子节点时 if(root.left==null &amp;&amp; root.right==null)&#123; //当前节点值与target值相等，说明path中的路径符合要求 if(num==target)&#123; ArrayList&lt;Integer&gt; tmp=new ArrayList&lt;Integer&gt;(); for(int i:path)&#123; tmp.add(i); &#125; //将当前搜索路径加入到result中 result.add(tmp); &#125; return; &#125; /* 注意每次递归向下搜索时应该将target值减去已搜索的节点值 每次回溯时应该移除该节点值 */ if(root.left!=null)&#123; pathList(root.left,target-num,result,path); path.pop(); &#125; if(root.right!=null)&#123; pathList(root.right,target-num,result,path); path.pop(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[]},{"title":"重建二叉树","slug":"重建二叉树","date":"2017-08-21T06:08:13.000Z","updated":"2017-08-21T07:16:11.951Z","comments":true,"path":"2017/08/21/重建二叉树/","link":"","permalink":"http://yoursite.com/2017/08/21/重建二叉树/","excerpt":"","text":"问题描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。分析假设输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6} 前序遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树 中序遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树 由前序和中序的遍历顺序我们可以得到以下信息： 1.前序序列的第一个节点总是该序列的根节点 2.在中序序列中，以1得到的根节点为界，左边的序列为根节点的左子树，右边的序列为右子树 3.通过2将前序和中序序列进行划分得到的左子树和右子树同样适用上述规则 显然，从信息3可以看出来这道题可以采用递归的方式解决 程序1234567891011121314151617181920212223242526272829303132//二叉树结构public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return myReConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); &#125;/*参数：前序序列，前序序列第一个元素和最后一个元素的索引，后序序列，后序序列第一个元素和最后一个元素的索引返回：重建二叉树的头结点*/ public TreeNode myReConstructBinaryTree(int pre[],int preHead,int preTail,int in[],int inHead,int inTail)&#123; //头索引大于尾索引，说明序列的左子树或者右子树为空，返回null if(preHead&gt;preTail || inHead&gt;inTail) return null; //前序序列的第一个节点是该序列的根节点 TreeNode root=new TreeNode(pre[preHead]); for(int i=inHead;i&lt;=inTail;i++)&#123; //在中序序列中找到该节点 if(pre[preHead]==in[i])&#123; //节点左边为左子树，右边为右子树，对他们分别进行重建二叉树的操作 root.left=myReConstructBinaryTree(pre,preHead+1,preHead+i-inHead,in,inHead,i-1); root.right=myReConstructBinaryTree(pre,preHead+i-inHead+1,preTail,in,i+1,inTail); &#125; &#125; //返回重建后的二叉树的根节点 return root; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-18T07:35:09.375Z","updated":"2017-08-21T01:01:01.837Z","comments":true,"path":"2017/08/18/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}