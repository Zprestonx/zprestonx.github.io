{"meta":{"title":"Zpreston","subtitle":null,"description":"Zpreston's Blog","author":"Zpreston","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-08-18T08:53:19.000Z","updated":"2017-08-18T08:53:19.936Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"重建二叉树","slug":"重建二叉树","date":"2017-08-21T06:08:13.000Z","updated":"2017-08-21T07:16:11.951Z","comments":true,"path":"2017/08/21/重建二叉树/","link":"","permalink":"http://yoursite.com/2017/08/21/重建二叉树/","excerpt":"","text":"问题描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。分析假设输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6} 前序遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树 中序遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树 由前序和中序的遍历顺序我们可以得到以下信息： 1.前序序列的第一个节点总是该序列的根节点 2.在中序序列中，以1得到的根节点为界，左边的序列为根节点的左子树，右边的序列为右子树 3.通过2将前序和中序序列进行划分得到的左子树和右子树同样适用上述规则 显然，从信息3可以看出来这道题可以采用递归的方式解决 程序1234567891011121314151617181920212223242526272829303132//二叉树结构public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return myReConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); &#125;/*参数：前序序列，前序序列第一个元素和最后一个元素的索引，后序序列，后序序列第一个元素和最后一个元素的索引返回：重建二叉树的头结点*/ public TreeNode myReConstructBinaryTree(int pre[],int preHead,int preTail,int in[],int inHead,int inTail)&#123; //头索引大于尾索引，说明序列的左子树或者右子树为空，返回null if(preHead&gt;preTail || inHead&gt;inTail) return null; //前序序列的第一个节点是该序列的根节点 TreeNode root=new TreeNode(pre[preHead]); for(int i=inHead;i&lt;=inTail;i++)&#123; //在中序序列中找到该节点 if(pre[preHead]==in[i])&#123; //节点左边为左子树，右边为右子树，对他们分别进行重建二叉树的操作 root.left=myReConstructBinaryTree(pre,preHead+1,preHead+i-inHead,in,inHead,i-1); root.right=myReConstructBinaryTree(pre,preHead+i-inHead+1,preTail,in,i+1,inTail); &#125; &#125; //返回重建后的二叉树的根节点 return root; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-18T07:35:09.375Z","updated":"2017-08-21T01:01:01.837Z","comments":true,"path":"2017/08/18/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}